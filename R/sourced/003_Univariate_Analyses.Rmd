---
title: ''
output: html_document
---

## About  

Each of the (up to) 4 response variables identified in the Analysis Specs spreadsheet, plus EMI (Ecotone Migration Index), species richness, and Shannon-Weiner Diversity Index, will have its results appear in its own tab. You will see the same tables and graphics for each.  

### Questions addressed  

-  Are there shifts in key vegetation species/groups over time?  
-  Do these shifts vary by vegetation zone?  
-  Follow-up: Where is the plant community changing (which plots) and what characteristics do those areas have in common (e.g. site, zone, distance from water, elevation)?  

### Reserve-identified response variables:  

The reserve-identified univariate response variables are:  

```{r show-userChoice-univar, results = 'asis'}
cat(paste("*", anaSpec_list$univar$Choice), sep="\n")
```

```{r mod-univar-df}
# widen out the univar data frame
# it's grouped appropriately for these analyses  
dat_univar <- anaSpec_dfs$univar %>% 
    pivot_wider(names_from = Species_or_Group,
                values_from = Cover)

# join EIR - use a join because might not be in same order
EMI_df <- dat %>% 
    select(StTrnsPlt, Year, Month, Day, EMI)

dat_univar <- left_join(dat_univar, EMI_df) %>% 
    left_join(dat_div)

# can join any other metrics here - e.g. richness, diversity  
```

```{r}
# remove plots that don't have at readings in at least 3 separate years
dat_univar <- filter(dat_univar, !(StTrnsPlt %in% not_enough$StTrnsPlt))
```


### Statistical Model  

The main statistical model used is a linear mixed model, via `lme4::lmer()`, with the form `y ~ Vegetation Zone + Time + Zone*Time + 1|Plot`, where `y` is the response variable given in the tab, and each individual plot has a random intercept. 



### Representation of Results  

Coefficient table  

ANOVA table; whether interaction between time and zone is significant  

Estimated marginal slopes (change within each zone)  

Contrasts plot  

```{r}
# set up a list of univariate output info
# estimates, CIs, etc.
univar_outputs <- list()
```



## EMI   

EMI, Ecotone Migration Index, is the proportional cover of species/covers or species/cover groupings that are expected to increase within a vegetation zone as sea level rises. These species were identified by reserve staff, for each zone, in the 'veg-specs.xlsx' file. 

Species considered to be 'migrators' within each zone are denoted by 'x' in the following table:  

```{r show-eir-spps}
kableExtra::kable(emi_spps, align = "c") %>% 
    kable_styling("striped") %>%
    scroll_box(width = "800px", height = "200px") 
```


```{r define-univar-EMI}
respn <- "EMI"
dat_univar$resp <- unlist(dat_univar[which(names(dat_univar) == respn)])
```


```{r source-003-EMI, child = "003a_model_run.Rmd"}

```



## Richness  

Species Richness, calculated on all non-abiotic, non-dead, and non-overstory columns; using the `vegan` package.

```{r define-univar-richness}
respn <- "Richness"
dat_univar$resp <- unlist(dat_univar[which(names(dat_univar) == respn)])
```

```{r source-003a-userChosen1b, child = "003a_model_run.Rmd"}

```



## Diversity  

Shannon-Weiner Diversity index, calculated on all non-abiotic, non-dead, and non-overstory columns; using the `vegan` package.  

```{r define-univar-diversity}
respn <- "SWdiv"
dat_univar$resp <- unlist(dat_univar[which(names(dat_univar) == respn)])
```

```{r source-003a-userChosen1c, child = "003a_model_run.Rmd"}

```




```{r, results = "asis"}
# user-identified univariate responses  
respns <- anaSpec_list$univar$Choice
for(i in seq_along(respns)){
    respn <- respns[i]
    cat("\n")
    cat("##", respn, "\n")
    dat_univar$resp <- unlist(dat_univar[which(names(dat_univar) == respn)])
    chld <- knitr::knit_child("003a_model_run.Rmd", quiet = TRUE)
    cat(chld, sep = "\n")
}
```


```{r, results = "asis"}
# custom metrics


# allow for custom names for the custom metrics
custom_name1 <- addlOptions$Choice[addlOptions$R_param == "Custom_metric1_name"]
custom_name1 <- ifelse(is.na(custom_name1) | custom_name1 == "", "Custom_metric1", custom_name1)

custom_name2 <- addlOptions$Choice[addlOptions$R_param == "Custom_metric2_name"]
custom_name2 <- ifelse(is.na(custom_name2) | custom_name2 == "", "Custom_metric2", custom_name2)

# process custom metrics 

# first custom metric
if("custom1" %in% anaSpecs$R_varName){
    user_formula1 <- anaSpecs$Choice[anaSpecs$R_varName == "custom1"]
    user_formula1_parsed <- rlang::parse_expr(user_formula1)
    terms1 <- extract_terms(user_formula1)
    dat_custom <- process_custom_metric_terms(terms = terms1,
                                              dat = dat)
    
    # make formulas vector for printing
    formulas <- user_formula1

}

# second custom metric - dat_custom should already exist from custom 1
if("custom2" %in% anaSpecs$R_varName){
    user_formula2 <- anaSpecs$Choice[anaSpecs$R_varName == "custom2"]
    user_formula2_parsed <- rlang::parse_expr(user_formula2)
    
    terms2 <- extract_terms(user_formula2)
    dat_custom <- process_custom_metric_terms(terms = terms2,
                                              dat = dat_custom)
    
    formulas <- c(formulas, user_formula2)
}

# if at least one custom metric exists,
# calculate it/them and run the analyses
if(exists("dat_custom")){
    # now that all the proper columns exist, do the math
    # custom metric 1 must exist for dat_custom to exist
    dat_custom <- dat_custom %>% 
        mutate(!!custom_name1 := !!user_formula1_parsed)
    
    # custom metric 2 may or may not exist, so make it an if statement
    if("custom2" %in% anaSpecs$R_varName){
        dat_custom <- dat_custom %>% 
            mutate(!!custom_name2 := !!user_formula2_parsed)
    }
    
    # select proper columns
    dat_custom <- dat_custom %>% 
        select(Reserve:Total,
               starts_with(custom_name1),
               starts_with(custom_name2))
    
    # call analyses here
    # custom metric columns:
    respns <- names(dat_custom)[which(names(dat_custom) %in% c(custom_name1, custom_name2))]
    # respns <- names(dat_custom)[which(str_starts(names(dat_custom), "Custom_metric"))]
    
    # join with the univariate data frame
    # left join so if for some reason there are extra rows in dat_custom
    # (maybe not enough years of data for some plots?)
    # they go away, and it matches other data used in univariate analyses
    dat_univar <- left_join(dat_univar, dat_custom)
    
    for(i in seq_along(respns)){
        respn <- respns[i]
        cat("\n")
        cat("##", respn, "\n")
        cat("\n", "This custom metric was calculated using the following formula: \n\n", formulas[i], "\n\n")
 
        dat_univar$resp <- unlist(dat_univar[which(names(dat_univar) == respn)])
        chld <- knitr::knit_child("003a_model_run.Rmd", quiet = TRUE)
        cat(chld, sep = "\n")
    }
    
}
```
